"""
Vulnerability Classifier using scikit-learn
"""

import asyncio
import numpy as np
from typing import List, Dict
import logging

log = logging.getLogger(__name__)

try:
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.preprocessing import LabelEncoder
    SKLEARN_AVAILABLE = True
except ImportError:
    SKLEARN_AVAILABLE = False
    log.warning("[VulnClassifier] scikit-learn not available")


class VulnerabilityClassifier:
    """ML-based vulnerability classifier"""
    
    def __init__(self):
        self.model = None
        self.label_encoder = None
        self.is_trained = False
        
        if SKLEARN_AVAILABLE:
            self.model = RandomForestClassifier(n_estimators=100, random_state=42)
            self.label_encoder = LabelEncoder()
    
    async def train(self, features: List[List[float]], labels: List[str]):
        """Train the classifier"""
        if not SKLEARN_AVAILABLE:
            log.warning("[VulnClassifier] Training skipped - scikit-learn not available")
            return
        
        log.info(f"[VulnClassifier] Training on {len(features)} samples")
        
        # Encode labels
        encoded_labels = self.label_encoder.fit_transform(labels)
        
        # Train model
        self.model.fit(features, encoded_labels)
        self.is_trained = True
        
        log.info("[VulnClassifier] Training complete")
    
    async def predict(self, features: List[float]) -> Dict:
        """Predict vulnerability type"""
        if not SKLEARN_AVAILABLE or not self.is_trained:
            return await self._fallback_predict(features)
        
        # Predict
        features_array = np.array([features])
        prediction = self.model.predict(features_array)[0]
        probabilities = self.model.predict_proba(features_array)[0]
        
        # Decode label
        vuln_type = self.label_encoder.inverse_transform([prediction])[0]
        confidence = float(max(probabilities))
        
        return {
            'vulnerability_type': vuln_type,
            'confidence': confidence,
            'all_probabilities': {
                self.label_encoder.inverse_transform([i])[0]: float(prob)
                for i, prob in enumerate(probabilities)
            }
        }
    
    async def _fallback_predict(self, features: List[float]) -> Dict:
        """Fallback prediction without scikit-learn"""
        # Simple rule-based prediction
        vuln_types = ['sql_injection', 'xss', 'command_injection', 'path_traversal']
        
        # Use feature values to determine type
        max_feature_idx = features.index(max(features)) if features else 0
        vuln_type = vuln_types[max_feature_idx % len(vuln_types)]
        
        return {
            'vulnerability_type': vuln_type,
            'confidence': 0.5,
            'all_probabilities': {vt: 0.25 for vt in vuln_types}
        }
